---
pagetitle: "Reconciliation Forecasting"
subtitle: "Land Transfer Duty"
author: "Hoang Do"
email: "vdoo0002@student.monash.edu"
date: "22-05-2024"
unit-url: "https://github.com/justin-git01/ltd_forecasting"
footer: "Department of Treasury and Finance"
format: 
  revealjs:
    slide-number: c
    width: 1280
    height: 720
    logo: images/monash-one-line-black-rgb.png
    theme: assets/monash.scss
    css: [assets/tachyons-addon.css, assets/custom.css]
    include-after-body: "assets/after-body.html"
execute:
  echo: false
---

```{r, include = FALSE}
current_file <- knitr::current_input()
basename <- gsub(".[Rq]md$", "", current_file)
library(tidyverse)
library(kableExtra)
library(readxl)
library(fpp3)
library(plotly)
library(ggplot2)
library(visNetwork)
library(tidygraph)
library(corrplot)
library(urca)
library(tseries)
knitr::opts_chunk$set(
  fig.path = sprintf("images/%s/", basename),
  fig.width = 6,
  fig.height = 4,
  fig.align = "center",
  out.width = "100%",
  fig.retina = 3,
  warning = FALSE,
  message = FALSE,
  cache = F,
  cache.path = "cache/"
)
```

```{r}
visnetwork_hierarchy <- function(data, ...) {
  nodes <- as_tibble(mutate(activate(data, "nodes"), id = row_number(), level = node_distance_from(node_is_root())))
  edges <- as_tibble(activate(data, "edges"))
  graph <- visNetwork(nodes, edges, ...) |> 
    visHierarchicalLayout(direction = "UD", shakeTowards = "leaves") |> 
    visOptions(
      highlightNearest = list(enabled = TRUE, degree = list(from = 50000, to = 0), hover = FALSE, algorithm = "hierarchical"), 
      collapse = list(enabled = TRUE, fit = FALSE, resetHighlight = TRUE, keepCoord = TRUE,
                      clusterOptions = list(fixed = TRUE, physics = TRUE))
    ) |> 
    visEdges(scaling = list(label = list(enabled = FALSE)), arrows = "to") |> 
    visNodes(font = list(size = 16))
  
  graph$x$tree <- list(updateShape = TRUE, shapeVar = "dot", shapeY = "square")
  graph
}
visnetwork_graph <- function(data, layout = "layout_nicely", ...) {
  nodes <- as_tibble(mutate(activate(data, "nodes"), id = row_number()))
  edges <- as_tibble(activate(data, "edges"))
  graph <- visNetwork(nodes, edges, ...) |> 
    visIgraphLayout(layout = layout, randomSeed = 123091238) |> 
    visOptions(
      highlightNearest = list(enabled = TRUE, degree = list(from = 50000, to = 0), hover = FALSE)
    ) |> 
    visEdges(width = 3, scaling = list(label = list(enabled = FALSE)), arrows = "to") |> 
    visNodes(size = 20)
  
  graph$x$tree <- list(updateShape = TRUE, shapeVar = "dot", shapeY = "square")
  graph
}
```


```{r}
# Load ltd aggregate date
ltd_agg <- read_excel(here::here("data/LTD_new.xlsx"), sheet = 1) |>
  rename(Date = ...1,
         ltd = LTD,
         sales = SALES,
         hvi = HVI) |>
  dplyr::select(c(Date, ltd, sales, hvi)) 

ltd_agg_ts <- ltd_agg |>
  mutate(Month = yearmonth(Date)) |>
  dplyr::select(-Date)  |>
  as_tsibble(index = Month) |>
  relocate(Month)

# Load ltd unit data
ltd_unit <- read_excel(here::here("data/LTD_new.xlsx"), sheet = 2) |>
  rename(Date = ...1) |>
  dplyr::select(Date, ltd_total, ltd_nonres, ltd_comm, ltd_ind, ltd_other, ltd_res)

ltd_unit_ts <- ltd_unit |>
  mutate(Month = yearmonth(Date)) |>
  dplyr::select(-Date)  |>
  as_tsibble(index = Month) |>
  relocate(Month)
```

```{r}
tax_rev <- read_excel(here::here("data/tax_rev.xlsx"), sheet = 2) |>
  rename(Date = ...1)|>
  mutate(reliance = `Reliance on stamp duty` *100 ) |>
  dplyr::select(Date, reliance) |>
  mutate(Quarter = yearquarter(Date)) |>
  dplyr::select(-Date)  |>
  as_tsibble(index = Quarter) |>
  relocate(Quarter)
```


## <br>[`r rmarkdown::metadata$pagetitle`]{.monash-blue} {#etc5523-title background-image="images/bg-01.png"}

### `r rmarkdown::metadata$subtitle`

Author: *`r rmarkdown::metadata$author`*

`r rmarkdown::metadata$department`

::: tl
<br>

<ul class="fa-ul">

<li>

[<i class="fas fa-envelope"></i>]{.fa-li}`r rmarkdown::metadata$email`

</li>

<li>

[<i class="fas fa-calendar-alt"></i>]{.fa-li} `r rmarkdown::metadata$date`

</li>

<li>

[<i class="fa-solid fa-globe"></i>]{.fa-li}<a href="`r rmarkdown::metadata[["unit-url"]]`">`r rmarkdown::metadata[["unit-url"]]`</a>

</li>

</ul>

<br>
:::


## {}
<center>
<img src="images/intro_pic.png" height = "620">

</center>

::: aside

Image generated by [ChatGPT](chat.openai.com).

:::

# Land Transfer Duty {background-color=#006DAE}

## {background-image="images/mel_city1.jpg"}

<center>
::: {.monash-bg-white .pa3 style="opacity:0.85;" .w-80}
::: callout-note

## What is Land Transfer Duty? (or Stamp Duty)

* Paid when a property is *bought* or *acquired*

* Varies by property *value*, *usage*, *buyer nationality*, and *eligibility for exemptions*.

:::
:::
</center>
<br>
<center>
```{r total_ltd, fig.height = 3.2, fig.width = 4, out.width="54%"}
plot_total <- ltd_agg_ts |> 
filter(Month > yearmonth(as.POSIXct("2000-01-01"))) |>
mutate(ltd_inM = ltd/1000000) |> 
autoplot(ltd_inM, color = "blue") +
labs(x = "Date", y = "Land Transfer Duty (in $million)", title = "Land Transfer Duty from 2010") +
theme_minimal()

ggplotly(plot_total)

```
</center>

## Impact of LTD

<center>
::: callout-warning

## On property market

* A 100 basis point cut in transfer duty could boost property transactions by 10%. (Source: [NSW Treasury](https://www.treasury.nsw.gov.au/sites/default/files/2021-06/the_economic_costs_of_transfer_duty_a_literature_review.pdf))

* Victoria's tax revenue is heavily dependent on land transfer duty

:::

```{r tax_revenue, fig.height = 3, fig.width = 4, out.width="50%"}
tax_revenue <- tax_rev |> 
autoplot(reliance, color = "blue") +
geom_hline(yintercept = mean(tax_rev$reliance), color = "red") +
labs(x = "Date", y = "Percentage", title = "Victoria tax revenue's reliance on LTD") +
theme_minimal()

ggplotly(tax_revenue)
```
</center>



## Current forecasting approach

::: callout-note
## Model used by DTF

* Cointegration pattern between LTD, Sales, and Home Value Index (HVI)

* Vector Error Correction Model (VECM)

* RMSE: >>>

:::



# Applying Forecast Reconciliation {background="#006DAE"}

## Hierarchical Time Series

::: callout-warning

## Limitations

* Characteristics of different levels may differ

* Include these features can improve forecast accuracy

:::

<center>
```{r}
#| echo: false
#| output: hide
tidygraph::tbl_graph(
  nodes = tibble(label = c("Total", "Non-Residential", "Residential", "Industry", "Commercial","Other")),
  edges = tibble(from = c(1, 1, 2, 2, 2), to = c(2, 3, 4, 5, 6))
) |>
  visnetwork_hierarchy(width = 750, height = 350)
```
</center>

## Notation

::: callout-note

## Hierarchy structure for LTD 

Can be written in matrix form: 

$$
\begin{bmatrix}
  \text{Total}_{t} \\
  \text{Non-residential}_{t} \\
  \text{Residential}_{t} \\
  \text{Commercial}_{t} \\
  \text{Industrial}_{t} \\
  \text{Other}_{t} \\
  \end{bmatrix}
=
\begin{bmatrix}
  1 & 1 & 1 & 1 \\
  0 & 1 & 1 & 1 \\
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
  \text{Residential}_{t} \\
  \text{Commercial}_{t} \\
  \text{Industrial}_{t} \\
  \text{Other}_{t} \\
\end{bmatrix}
$$
or in a more compact notation:

$$
\text{LTD}_{t} = \text{S}\text{b}_{t},
$$
:::

## Temporal hierarchy 

::: {.callout-note}

A time series can be disaggregated by temporal frequencies
<center>
```{r}
tidygraph::tbl_graph(
  nodes = tibble(label = c("Year", "Q1", "Q2", "Q3", "Q4", month.abb)),
  edges = tibble(from = c(rep(1, 4), rep(2:5, each = 3)), to = c(2:17))
) |>
  visnetwork_hierarchy(width = 600, height = 200) |> 
  visNodes(font = list(size = 40))
```
</center>
:::

::: {.callout-paper}
Temporal reconciliation is described in Athanasopoulos et al. (2017).
:::


# Forecast ALL series {background="#006DAE"}



## {auto-animate=true}

::: {style="margin-top: 200px; font-size: 3em; color: red;"}
Forecast at different levels don't add up!
:::

## {auto-animate=true}

::: {style="margin-top: 100px;"}
Forecast at different levels don't add up!
:::

::: {.callout-important}

Independently produced forecasts are [**incoherent**]{.danger},

$\text{LTD}_{T+h|T} \neq \text{Comm}_{T+h|T} + \text{Ind}_{T+h|T} + \text{Other}_{T+h|T} + \text{Residential}_{T+h|T}$.

Or for temporal hierarchy

$\text{Year}_{T+h|T} \neq \text{Jan}_{T+h|T} + \text{Feb}_{T+h|T} + \text{Mar}_{T+h|T} + ... + \text{Dec}_{T+h|T}$.
:::


# Reconciliation {background="#006DAE"}



## 2-step reconciliation process

::: callout-note

* First obtain a set of base forecast $\hat{\text{y}}_{h}$, 

* Then all coherent forecast can be represented as:
<center>
$\tilde{\text{y}}_{h} = \text{SG}\hat{\text{y}}_{h}$, 
</center>

where **G** is a matrix that maps the base forecasts into the bottom level, and the summing matrix **S** sums these up using the aggregation structure to produce a set of **coherent forecasts** $\tilde{\text{y}}_{h}$

:::

# Minimize variance {background="#006DAE"}

## MinTrace

::: callout-note
**Wickramasuriya et al. (2019)** shows that the variance-covariance of the h-step-ahead coherent forecast errors is given by:

<center>
$\text{V}_{h} = Var[\text{y}_{T+h} - \tilde{\text{y}}_{h}] = SG\text{W}_{h}G'S'$,
</center>

where $\text{W}_{h} = Var[\text{y}_{T+h} - \hat{\text{y}}_{h}]$ is the variance-covariance matrix of the corresponding base forecast errors.

The objective is to find a matrix **G** that minimises the error variances of the coherent forecasts.

:::

## FoReco package

:::rows
<center>
![](images/logo.svg) 
</center>
:::

::: rows
::: flex

![](images/Tommaso.jpeg) 

![](images/Daniele.jpeg)
:::
::: 

## Results




## Recap 


::: callout-important

## Summary

:::


## Addtional Resources

::: callout-tip

## Research Paper

:::

## {}

